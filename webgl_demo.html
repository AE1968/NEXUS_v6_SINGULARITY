<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Geneza Nexus - WebGL Shader Morphing Simulation</title>
    <style>
        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #00f3ff;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border: 1px solid #00f3ff;
            border-radius: 8px;
        }

        .control-group {
            margin-bottom: 10px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }

        input[type="range"] {
            width: 200px;
            accent-color: #00f3ff;
        }

        #debug-info {
            font-size: 10px;
            color: #888;
            margin-top: 10px;
        }
    </style>
</head>

<body>

    <div id="controls">
        <h3>SHADER CORE SIMULATION</h3>

        <div class="control-group">
            <label>AUDIO FREQUENCY (Mouth Open Y)</label>
            <input type="range" id="audioY" min="0" max="1" step="0.01" value="0">
        </div>

        <div class="control-group">
            <label>AUDIO INTENSITY (Mouth Widen X)</label>
            <input type="range" id="audioX" min="0" max="1" step="0.01" value="0">
        </div>

        <div class="control-group">
            <label>EYE TRACING (Manual X)</label>
            <input type="range" id="eyeX" min="-1" max="1" step="0.01" value="0">
        </div>

        <div id="debug-info">
            GLSL FRAGMENT SHADER RUNNING<br>
            VERTEX DISPLACEMENT ACTIVE<br>
            AVATAR: KELION (MALE)
        </div>
    </div>

    <canvas id="glCanvas"></canvas>

    <!-- VERTEX SHADER: Handles geometry position -->
    <script id="vertex-shader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    attribute vec2 a_texCoord;
    uniform vec2 u_resolution;
    varying vec2 v_texCoord;

    void main() {
        // Convert from pixels to 0.0->1.0 to -1.0->+1.0
        vec2 zeroToOne = a_position / u_resolution;
        vec2 zeroToTwo = zeroToOne * 2.0;
        vec2 clipSpace = zeroToTwo - 1.0;

        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
        v_texCoord = a_texCoord;
    }
</script>

    <!-- FRAGMENT SHADER: This is where the MAGIC happens (Pixel manipulation) -->
    <script id="fragment-shader" type="x-shader/x-fragment">
    precision mediump float;

    uniform sampler2D u_image;
    uniform vec2 u_resolution;
    uniform float u_audioY; // Mouth opening (Bass/Vowels)
    uniform float u_audioX; // Mouth widening (Treble/Consonants)
    uniform vec2 u_mouse;   // Eye look direction
    uniform float u_time;   // For organic noise

    varying vec2 v_texCoord;

    // Define face regions (Normalized 0.0 - 1.0 based on texture)
    // These would be calibrated for each avatar
    const vec2 MOUTH_CENTER = vec2(0.5, 0.65); // Approx mouth position
    const vec2 LEFT_EYE = vec2(0.43, 0.45);
    const vec2 RIGHT_EYE = vec2(0.57, 0.45);

    void main() {
        vec2 uv = v_texCoord;
        vec2 distortedUV = uv;

        // --- 1. MOUTH DEFORMATION (Audio Reactive) ---
        float mouthDist = distance(uv, MOUTH_CENTER);
        
        // Influence radius for mouth
        if (mouthDist < 0.08) {
            // Calculate pull factor (stronger at center, zero at edges)
            float pull = smoothstep(0.08, 0.0, mouthDist);
            
            // Vertical Open Stretch (Y-axis)
            distortedUV.y -= u_audioY * 0.05 * pull; 
            
            // Horizontal Widen Stretch (X-axis) - Subtle
            distortedUV.x -= (uv.x - MOUTH_CENTER.x) * u_audioX * 0.2 * pull;
        }

        // --- 2. EYE REFRACTION (Mouse Tracking) ---
        // Left Eye
        float leftEyeDist = distance(uv, LEFT_EYE);
        if (leftEyeDist < 0.04) {
             float lensEffect = smoothstep(0.04, 0.0, leftEyeDist);
             // Shift texture opposite to mouse to simulate 3D cornea rotation
             distortedUV += u_mouse * 0.02 * lensEffect; 
        }

        // Right Eye
        float rightEyeDist = distance(uv, RIGHT_EYE);
        if (rightEyeDist < 0.04) {
             float lensEffect = smoothstep(0.04, 0.0, rightEyeDist);
             distortedUV += u_mouse * 0.02 * lensEffect;
        }

        // --- 3. SUBTLE BREATHING (Perlin noise simulation) ---
        // float breath = sin(u_time * 2.0) * 0.002;
        // distortedUV.y += breath * uv.y; // Slight vertical stretch

        gl_FragColor = texture2D(u_image, distortedUV);
    }
</script>

    <script>
        // WebGL Boilerplate Setup
        const canvas = document.getElementById("glCanvas");
        const gl = canvas.getContext("webgl");

        if (!gl) { alert("WebGL not supported"); }

        // Shader Compiler
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShaderSource = document.getElementById("vertex-shader").text;
        const fragmentShaderSource = document.getElementById("fragment-shader").text;

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(program));
        }

        // Look up locations
        const positionLocation = gl.getAttribLocation(program, "a_position");
        const texCoordLocation = gl.getAttribLocation(program, "a_texCoord");

        const resolutionLocation = gl.getUniformLocation(program, "u_resolution");
        const audioYLocation = gl.getUniformLocation(program, "u_audioY");
        const audioXLocation = gl.getUniformLocation(program, "u_audioX");
        const mouseLocation = gl.getUniformLocation(program, "u_mouse");
        const timeLocation = gl.getUniformLocation(program, "u_time");

        // Buffers
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        setRectangle(gl, 0, 0, canvas.width, canvas.height); // Initial size

        const texCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            0.0, 0.0,
            1.0, 0.0,
            0.0, 1.0,
            0.0, 1.0,
            1.0, 0.0,
            1.0, 1.0,
        ]), gl.STATIC_DRAW);

        // Texture Loading
        const image = new Image();
        image.src = "/assets/humanoid_male.png"; // Load KELION for simulation
        image.onload = function () {
            render();
        };

        function createTexture(gl) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
            return texture;
        }

        // Rendering Loop
        function render() {
            resizeCanvasToDisplaySize(gl.canvas);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);

            gl.enableVertexAttribArray(positionLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            // Update rectangle to match canvas size
            setRectangle(gl, 0, 0, gl.canvas.width, gl.canvas.height);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(texCoordLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

            // Uniforms
            gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);

            // Pass Control Values
            gl.uniform1f(audioYLocation, document.getElementById('audioY').value);
            gl.uniform1f(audioXLocation, document.getElementById('audioX').value);

            const eyeX = parseFloat(document.getElementById('eyeX').value);
            gl.uniform2f(mouseLocation, eyeX, 0.0); // Only X tracking for demo
            gl.uniform1f(timeLocation, performance.now() / 1000);

            // Upload texture
            createTexture(gl);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            requestAnimationFrame(render);
        }

        function setRectangle(gl, x, y, width, height) {
            var x1 = x;
            var x2 = x + width;
            var y1 = y;
            var y2 = y + height;
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                x1, y1,
                x2, y1,
                x1, y2,
                x1, y2,
                x2, y1,
                x2, y2,
            ]), gl.STATIC_DRAW);
        }

        function resizeCanvasToDisplaySize(canvas) {
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
            }
        }
    </script>

</body>

</html>